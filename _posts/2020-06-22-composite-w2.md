---
layout: post
title: "Cousera笔记 - 计算机组成2 · 指令系统体系结构"
date: 2020-06-22
excerpt: "x86 ISA体系结构，MIPS体系结构 ISA..."
tags: [学习笔记, coursera, 计算机组成, 2020]
feature: https://www.gla.ac.uk/media/Media_299663_smxx.jpg
comments: true
---

[参考课程 - 计算机组成](https://www.coursera.org/learn/jisuanji-zucheng/home/week/3)

* 目录
{:toc}

## 指令系统体系结构ISA

### 设计自己的计算机

#### 简单计算机指令系统(设计)

![](/static/2020-06-22-15-48-15.png)

> **先根据需求要设计所需要的指令**

* **运算类指令**
  * `ADD R,M` - 将寄存器与存储器中的数相加，然后存入寄存器
* **传送类指令**
  * `LOAD R,M` - 将操作数M放入操作数R
  * `STORE R,M` - 将寄存器R中的数放入M所指定的存储单元
* **转移类指令**
  * `JMP L` - 转移/跳转到L所指向的存储器地址, 取出指令来执行

#### 指令格式

> 进一步规定指令对应的可识别**二进制**编码

🍊 规定

![](/static/2020-06-22-17-19-35.png)

* 每条指令等长，2字节
* 第一个字节<font color="red">高四位</font> - <font color="blue">操作码</font>
  * _决定指令类型_
  * `LOAD - 0000`
  * `ADD - 0001`
  * `STORE - 0010`
  * `JMP - 0011`
  * ...最多可支持\(2^4=16\)条
* 第一个字节<font color="red">低四位</font> - <font color="blue">寄存器号R</font>
  * R0...R3: `0000~0011`，4个CPU通用寄存器
  * ...最多可支持\(2^4=16\)个通用寄存器，R0...R15
* <font color="red">第二个字节</font>
  * 存储单元地址
  * 8bit，可以访问到存储地址\(2^8=256\)

##### 运算任务实例

![](/static/2020-06-22-17-44-18.png)
![](/static/2020-06-22-18-49-17.png)

🍬 最早需要直接编写<font color="blue">机器码</font>，并在穿孔纸带上嵌上对应0/1小孔，送入计算机

* 低效，易出错

🍬 后进步，可以编写<font color="blue">汇编语言</font>

* 易编写，后续可以通过工具将汇编语言->机器码->被计算机识别

🍬 高级语言->低级语言->汇编语言->机器码

🍬 设计时要规定，启动时/复位完成后，第一条指令位置

* 没有强制规定，但通常约定为能访问的存储单元最小地址，`0`或最高地址

---

🍊 在存储器中的程序(二进制机器码形式)

![](/static/2020-06-22-18-51-53.png)

* 上图为存储器某地址片段存储的数据&指令

---

## x86体系结构

![](/static/2020-06-22-21-09-03.png)

> x86是**商业最为成功，影响力最大**的一种体系结构
>
> *上图为最具代表性的x86ISA微处理器*

### Intel 8086 - 1978

![](/static/2020-06-22-23-10-08.png)

> 最早1978年推出
>
> * 16bit (字长2) - **CPU运算部件支持16bit数据运算(也能处理8bit)**
> * 对外连接存储器M的**地址总线位宽为20bit**，**可寻址内存空间2^20=1MByte**
> * **数据总线位宽为16bit**
> * **物理地址**形成采用“**段+偏移**”方式

🍬 运算数据通常需要存储在通用寄存器中，因此<font color="blue">寄存器位宽 & 运算单元位宽相同</font>

🍬 同理，通常需要将通用存储器数据存入存储器M，因此<font color="blue">寄存器位宽 & CPU<b>访问存储器地址位宽(地址总线)</b>常常相同</font>【不一定一定相同】

🍊 此例intel8086地址线&CPU运算单元字长并不对应，因此<font color="blue">需要特殊方式生成访问存储器的地址</font>

#### 8086寄存器模型

🍊 分类

![](/static/2020-06-22-23-26-33.png)

* **通用寄存器**(多功能) - 16bit
* **指令指针寄存器** - IP16bit
  * <font color='blue'>注意8086对外地址线为20bit连接1M字节存储器</font>
* **标志寄存器** - 16bit
* **段寄存器** - 16bit

##### 通用/多功能寄存器

![](/static/2020-06-22-23-32-58.png)

> 8086主要有 **AX,BX,CX,DX** 作为**存储数据的通用寄存器(多功能)**
>
> **SP,BP,SI,DI**这4个通用寄存器**早期**有**特殊用途**，但随着x86ISA不断更新，大多成为了用于**保存【普通数据】的寄存器**

* `AX,BX,CX,DX` - 16bit
  * <font color="blue">每个又可分为两个8bit寄存器使用</font>
  * 可用于大多算术&逻辑运算指令

🍬 这些通用寄存器(多功能)除存放数据外，还有专门用途

* `AX` - Accumulator
  * 存放乘除等指令的操作数
* `BX` - Base
  * 存放存储单元偏移地址
* `CX` - Count
  * 存放计数值
* `DX` - Data
  * 乘法运算产生的部分积
  * 除法运算的部分被除数

##### 标志寄存器

![](/static/2020-06-22-23-38-31.png)

🍙 如ALU进行运算时，

* 将`x,y`输入相加后结果存入`z`，可能存在`carry`进位，就可以将该`carry`<font color="blue">进位存入标志寄存器`F`中</font>

---

🍊 8086标志寄存器 - **16bit**

![](/static/2020-06-23-11-27-14.png)

> 称为FLAGS，该标志寄存器中，<font color="blue">包含若干个标志位</font>，可分为2大类

🍬 标志位

* **状态标志**
  * <font color="blue">CPU工作状态</font>
  * 如，加法运算是否产生进位，运算结果是否为0
* **控制标志**
  * <font color="blue">对CPU运行起特定控制作用</font>
  * 如，以单步方式还是连续方式运行，是否允许响应外部中断请求

###### 8086标志位

🍊 8086标志寄存器共<font color="blue">16bit</font>，但实际<font color="blue">只有部分有具体含义</font>

* 红色 - <font color="blue">状态标志</font>
  * `OF` - 溢出标志
  * `SF` - 符号标志
  * `ZF` - 零标志
  * `AF` - 半进位标志
  * `PF` - 奇偶标志
  * `CF` - 进位标志
    * 如进行加法后<font color="blue">产生进位，硬件自动设置，</font>状态标志`CF=1`
* 紫色 - <font color="blue">控制标志</font>
  * `DF` - 方向标志
  * `IF` - 中断标志
  * `TF` - 跟踪标志

##### 指令指针寄存器

🍙 对应先前模型机的PC寄存器(program counter)

🍬 CPU每次执行下条指令之前，会将PC地址存入MAR以通过数据总线，获取对应地址存储单元的数据

🍊 intel 8086 - 指令指针寄存器 **IP**(Instruction Pointer)

![](/static/2020-06-23-22-53-24.png)

* <font color="blue">保存一个内存地址，指向当前需要取出的指令</font>
* 当CPU从内存中取出一个指令后，<font color="red">IP自动增加，指向下一指令地址</font>(实际情况更复杂)
* 程序员不能直接修改IP寄存器
  * <font color="blue">顺序指令 & 转移指令 & 过程调用/返回指令 会改变IP寄存器</font>

🍬 IP寄存器位宽<font color="red">16bit，此例<b>对外数据线</b>位宽20bit(包含额外4bit地址线)</font>

* IP寄存器只能访问\(2^16=65536(64K)\)字节内存单元，<font color="blue">过于小，无法满足当时大多数程序要求</font>
* <font color="red">实际8086对外连接1M字节的存储器，需要有位宽20bit的地址线进行寻址访问</font>

##### 段寄存器

🍊 <font color="blue">解决8086IP指令指针寄存器访址需求不够的问题</font>

🍊 段寄存器 Segment Register

> 用于与其他寄存器联合生成存储器地址.

🍬 8086有4个段寄存器

* `CS` - 代码段寄存器 (Code Segment)
* `DS` - 数据段寄存器 (Data Segment)
* `ES` - 附加段寄存器 (Extra Segment)
* `SS` - 堆栈段寄存器 (Stack Segment)

###### 8086物理地址

🍊 如从内存中，取出某地址数据

🍬 逻辑地址

> 又称**相对地址**，是访问地址的操作数。
>
> **段基址** ：**偏移量**

* 段寄存器 - <font color="blue">段基值(16bit)</font>
* 程序中给出地址 - <font color="blue">偏移量(16bit)</font>

---
🍊 物理地址

> 访问内存的实际有效地址。**20bit**
>
> **物理地址 = 段基址×16 + 偏移量**
>
> (即，base × 10H + offset)

🍊 假设段寄存器存放16bit，`2000H`，根据当前程序运行状况，`IP=3000H`

* 下条指令地址由<font color="blue">CPU内部硬件单元 - 移位器</font><font style="text-decoration:underline">负责移位</font>
* `2000H` 左移4bit -> `20000H`
* `20000H` + `3000H(offset)` = `23000H` 通过<font color="blue">地址加法器</font>
* CPU将该地址`23000H`通过`MAR`地址线发送至存储器，选中对应存储单元中指令编码or数据

---

###### 模型机实例

![](/static/2020-06-24-11-15-48.png)

* `MOV AX, [3000H]`指令将`3000H(offset)`所指向的内存地址中数据取出，存入`AX`
* 注意8086地址线20bit，必须采用**段+偏移**形式计算地址
* 假设`DS`(数据)段寄存器存储`2000H`，CPU读取该`DS`送至移位器左移4bit，再通过地址加法器得到20bit物理地址
* 20bit物理地址传入MAR->地址总线，取出对应存储单元数据->MDR->数据总线
* CPU读取CPU-MDR内容，存入AX

🍬 效率非常低，<font color="blue">取指&执行指令都需要进行段+偏移计算</font>

### Intel 80386 - 1985

🍬 基于8086体系结构进行改进

🍊 80386特点

![](/static/2020-06-24-11-53-37.png)

* x86系列中<font color="blue">第一款32bit微处理器，32bit x86体系结构也称IA-32</font>
* 支持`32`bit算术&逻辑运算，提供`32`bit通用寄存器
* 对外地址总线位宽`32`bit，可寻址空间`4GB`
  * 2^2 * 2^30 B = 4GB

🍬 <font color="blue">80386对运行模式进行了改进</font>，以便更稳定支持OS&软件

* <font color="blue">保护模式</font>
  * 如**段范围**可达4GB(2^32B)，(防溢出?)
* <font color="blue">虚拟8086模式</font>
  * 支持同时模拟多个8086微处理器
* <font color="blue">实模式</font>
  * 8086时代仅有的单一工作模式，最大分段仅为`64`KB(<font color="blue">2^16B</font>)，最大寻址空间`1`MB
  * 实模式下，内存寻址方式与8086相同，如80386可以使用`32`bit指令，用作高速8086

#### IA-32寄存器模型

🍊 32bit x86体系结构也称`IA-32`

🍬 其寄存器模型基于8086的16bit模型改进而来

* 如8086的`AX`通用寄存器，添加`16`bit后变成`32`bit`EAX`寄存器，<font color="blue">但仍可以继续使用AX寄存器处理16bit数据,或分成AH,AL两个8bit寄存器</font>

---

![](/static/2020-06-24-21-47-09.png)

🍙 8个通用寄存器(4个多功能，4个普通) - 32bit

* `EAX，EBX,ECX,EDX`
* `ESP,EBP,SSI,EDI`

🍙 1个标志寄存器EFLAGS - 32bit
tang

🍙 指令指针寄存器EIP - 32bit

* 可访问2^32B=**4GB内存空间**，<font color="blue">可以满足大多程序要求</font>

🍙 6个段寄存器(源8086体系结构的4个+2个新段寄存器)

* 运行于<font color="blue">保护模式中，最大分段范围支持2^32B=4GB</font>，使用方法有区别

### x86-64

🍊 后续IA-32ISA的4GB内存空间限制了大规模应用程序，<font color="green">intel继续改进提出了不兼容的IA-64体系结构</font>。<font color="blue">AMD提出了兼容的64bitx86方案</font>

> 该方案有不同名字如，AMD64,INTEL64

* 通常称为<font color="blue">x86-64</font>

#### x86-64寄存器模型

🍊 基于IA-32的32bit寄存器模型上进行扩展(除段寄存器之外，扩展新32bit)

![](/static/2020-06-24-22-17-22.png)

🍬 常用操作数存入寄存器比存入存储器效率更高，因此<font color="blue">更多寄存器性能越好</font>

* `x86-64`<font color="red">新增8个64bit通用寄存器</font>
  * 编号`R8...R15`
* 除段寄存器之外，均为`64`bit寄存器
* 如`RIP`指令指针寄存器，<font color="blue">允许内存访址空间为2^64B</font>

## x86指令简介

🍬 <font color="blue">x86指令系统是变长指令，可根据需要设定指令编码长度，灵活</font>

* 但是会给CPU<font color="red">取指带来麻烦，因为无法先前判断指令字节长度</font>
  * 取少，指令编码不全
  * 取多，浪费时间，占用CPU内部空间

### 指令主要类别

![](/static/2020-06-25-10-06-44.png)

* <font color="blue">运算类指令</font>
  * 加减乘除，算术运算
  * 与或非，逻辑类运算
* <font color="blue">传送类指令</font>
  * 例如，把数据从存储器送至寄存器，把数据从通用寄存器送至I/O接口
* <font color="blue">转移类指令</font>
  * 例如，无条件转移，条件转移，过程调用等
* <font color="blue">控制类指令</font>
  * 例如，对CPU进行控制，暂停处理器，清除标志位

#### 指令运行结果

![](/static/2020-06-25-10-14-55.png)

* 改变通用寄存器内容
  * `ADD,AX,DX`
* 改变存储单元内容
  * `MOV [10H],CX`
* 改变标志位
  * 如产生进位
* 改变指令指针
  * `JMP [BX]`
* 改变外设端口的内容
  * 访问显示端口
* 其他...

🍬 针对每条指令，考虑改变了什么

#### 传送指令

![](/static/2020-06-25-11-03-13.png)

> 把数据或地址传送到寄存器或存储器单元中

🍊 分组

* **通用数据**传送指令
* **累加器专用**传送指令
* **地址**传送指令
* **标志**传送指令

---

##### MOV指令和寻址方式示例

🍬 <font color="blue">x86指令系统是变长指令，可根据需要设定指令编码长度，灵活</font>

🍊 `MOV`指令

* 格式
  * `MOV DST,SRC`
* 操作
  * DST<-SRC
* 说明
  * `DST` - 目的操作数
  * `SRC` - 源操作数
  * `MOV`指令把一个操作数从源传送至目的，原操作数保持不变

---

![](/static/2020-06-25-14-26-45.png)

🍊 `MOV EBX, 40`

* 直接给出源操作数的值`40`，<font color="blue">会直接体现在取回的指令编码中</font>，之后直接将该数送至`EBX`中
* `40`称为<font color="blue">立即数</font>?

🍊 `MOV AL, BL`

* 给出存放源操作数的寄存器名称

🍊 `MOV ECX, [1000H]`

* 将`1000H`所指向的存储器单元中内容取出，作为源操作数

🍊 `MOV [DI], AX`

* 将`AX`寄存器中内容传送到存储单元
* 目的操作数，存储单元地址存放在`DI`寄存器中
* 执行时: CPU需要先从DI寄存器中取出访问存储器的地址，再从AX中取出数，执行写存储器操作

🍊 `MOV WORD PTR[BX+SI*2+200H], 01H`

* 给出<font color="blue">存放操作数存储器地址</font>的<font color="blue">寄存/计算方法</font>
* `WORD PTR`关键字
  * <font color="blue">表示该内存地址指向的是长度为1个字(2个字节)的内存单元</font>
* 将`01H`这个数存入该内存单元中，而给出了计算该内存单元地址的过程
  * CPU从`SI`寄存器中取出1个数，`*2`后 + 从`BX`中取出一个数 + `200H`，<font color="blue">完成运算后得出存储器地址</font>

###### MOV指令编码实例

![](/static/2020-06-25-15-08-20.png)

* 第一行
  * 3个字节的含义
* 第二行
  * 具体编码例子
  * 第1个字节，高4位bit指定指令类型`1011 -> MOV`
  * 第1个字节，低3位bit指定寄存器编号`000 -> AX`
  * 第2 & 3个字节 -> 该指令立即数`10EE`

🍬 CPU取回指令编码(译码后)，知道将后两个字节的内容（立即数`10EEH`）写入`AX`寄存器

---

![](/static/2020-06-25-15-35-15.png)

🍬 将存储器数据传送至寄存器, 复杂`MOV`指令，4个字节

* 存储单元地址
  * `BX+1004H(立即数)`，<font color="blue">该立即数会体现在指令编码中</font>
* 寄存器`reg`位域`011`对应`BX`

#### 运算类指令

🍊 运算类指令包括

![](/static/2020-06-25-15-41-56.png)

* **逻辑运算指令 & 移位指令**
* **算术运算指令**

##### 逻辑运算&移位指令

![](/static/2020-06-25-21-53-22.png)

🍊 作用

* <font color="blue">实现对二进制位的操作和控制</font>
* 又称“位操作指令”

🍊 操作数的限制

* 对于单操作数指令，操作数不能是立即数
* 对于双操作数指令，限制与`MOV`指令相同

##### 算术运算指令

![](/static/2020-06-25-22-08-12.png)

🍊 作用

* 完成**加、减、乘、除**等算术运算
* 提供运算结果调整、符号扩展等功能

🍊 操作数限制

* 目的操作数不能是立即数或`CS`寄存器
* 两个操作数不能同时为存储器操作数

---

###### 加法类指令

🍬 以加法指令为例

![](/static/2020-06-28-18-52-32.png)

* ADD指令(普通加) - `ADD DST, SRC`
  * operation: `DST<- DST + SRC`
  * ![](/static/2020-06-25-22-24-24.png)
* <font color="blue">INC增量指令</font>(加1) - `INC OPR`
  * operation: `OPR <- OPR + 1`
  * `INC CL`: <font color="blue">只有一个操作数</font>，结果仍存放至`CL`寄存器
  * <font color="red">指令编码长度为【1字节】，最短的x86指令之一</font>
  * <font style="text-decoration:underline">为该类似的常用操作设计短指令，大大减少程序代码长度</font>(在存储空间有限情况下，有实用)
* <font color="blue">ADC指令(带carry的加法)</font> - `ADC DST, SRC`
  * operation: `DST <- DST + SRC + CF`
  * 两个操作数相加+`CF`<font color="blue">(进位)标志位</font>，结果存入第一个操作数

###### 加法：结合模型机

![](/static/2020-06-27-17-24-17.png)

🍊 8086的标志位

* `ADD` & `ADC`指令都会根据运算结果改变标志寄存器中的`CF`位
* `ADC`指令会将`CF`位<font color="blue">加入到当前运算中</font>

---

🍊 CPU控制指令

🍊 `CLC`

> 把标志寄存器当中的**CF位**清零

![](/static/2020-06-27-17-40-42.png)

* 注意`INC`能不能替换成`ADD`，要考虑<font color=""></font>是否影响`CF`，因为有可能产生进位

###### 扩展: 减法类

🍊 `DEC reg`

* 将寄存器的内容减`1`

#### 转移类指令

> 根据**是否有判断条件**，分为
>
> * 无条件转移指令
> * 条件转移指令
>
> 根据转移目标地址的提供方式，分为
>
> * 直接转移
> * 间接转移

![](/static/2020-06-28-18-29-08.png)

🍊 作用

* 改变指令执行顺序

##### 条件转移指令

![](/static/2020-06-28-20-05-31.png)

> 需要条件转移时，需要**根据判断条件**选择**合适的转移指令**

🍬 如上，当`ZF=0`时，转移

---

🍙 复杂条件

![](/static/2020-06-28-20-08-22.png)

> 将多个**标志位组合**，作为转移的判断条件

##### 条件直接转移指令

* `JNZ`指令
  * 条件满足时，实现跳转(到*<font color="blue">标号 - label: 所指向的指令地址</font>)
  * 条件不满足时，执行后续指令
  * <font color="blue">实质是检查标志寄存器中的标志位</font>

🍬 当CPU运行到`JNZ`指令时，CPU首先检查标志寄存器中的`ZF`位，从而决定如何改变下条指令地址

###### 8086标志位: ZF

🍊 标志寄存器中的`ZF`标志位，

* 如果`DEC`指令结果为`0`，`ZF=1`
* 如果`DEC`指令结果不为`0`，`ZF=0`

#### 控制类指令

![](/static/2020-06-28-20-11-10.png)

🍊 作用

* 控制CPU功能
* 对<font color="blue">标志位</font>进行操作

🍊 `CLC`指令 - clear carry

* 将进位标志`CF`清`0`

🍊 `CLD`指令 - clear direction

* 将方向标志`DF=0`，用于设置串传送方向
* 源串低地址开始传送，`SI`&`DI`自动增量

🍊 `STD`指令 - set direction

* 将方向标志`DF=1`，用于设置串传送方向
* 源串高地址开始传送，`SI`&`DI`自动减量

## 复杂x86指令举例

### 串操作指令

![](/static/2020-06-29-14-48-36.png)

> 将**存储器中**的**数据串**进行每次**单元素**的操作

* 存储器中<font color="blue">串的基本单位(一个元素)</font>是
  * **字节**
  * **字**
* <font color="blue">串长度</font>
  * `64`KB

🍬 被传送的数据串称为<font color="blue">源串</font>

* 默认存放(逻辑)地址 - `DS:SI`寄存器组指向的地址

🍬 传送的目的,称为,<font color="blue">目的串地址</font>

* 默认存放地址 - `ES:DI`寄存器组指向的位置

---

![](/static/2020-06-29-15-07-42.png)

🍊 x86提供<font color="blue">5种不同串操作</font>指令

🍊 另有<font color="blue">3种重复前缀</font>，可与串操作指令配合使用

### 串传送指令说明: MOVSB

🍊 `MOVSB`指令(字节串传送)

* <font color="red">无其他操作数</font>
* 操作
  * 在存储器中将<font color="blue">指定位置的一个<b>字节BYTE</b>单元</font>传送到<font color="blue">另一个指定位置</font>
* 常用<font color="red">重复前缀</font>
  * `REP` - <font color="blue">无条件重复前缀</font>
    * 格式: `REP 串操作指令`
    * 操作: 当`CX≠0`时，<font color="blue">(无条件)重复执行串操作指令</font>

#### MOVSB指令示例

🍊 假设存储器中需要，进行一次数据串传送

![](/static/2020-06-29-22-18-11.png)

🍊此例为，`IA-16`,8086体系结构，

* 注意实模式下最大分段支持`2^16B=64KB`
* 对外连接`1M=2^10KB=2^20B`存储器

🍬 <font color="red">段寄存器之间不能直接传送</font>，需要借用<font color="blue">通用寄存器</font>

🍬 `SI`保存源串偏移地址，`DI`保存目的串偏移地址

##### 串传送指令实质

🍬 <font color="green">串传送指令实质</font>

* CPU对源串地址发起
  * 读操作
* CPU对目的串地址发起
  * 写操作
* 完成后，硬件自动
  * 修改`SI`&`DI`寄存器，指向后续串字(节)
  * 如使用重复前缀，则`CX := CX - 1`。(如`REP`前缀)当`CX≠0`时，无条件重复执行串操作指令

### 串操作指令特性

🍬 x86系统有很多无操作数指令，实质不一定是没有操作数，而可能是操作数过多，写不下

🍬 被传送的数据串称为<font color="blue">源串</font>

* 默认存放(逻辑)地址 - `DS:SI`寄存器组指向的地址

🍬 传送的目的,称为,<font color="blue">目的串地址</font>

* 默认存放地址 - `ES:DI`寄存器组指向的位置

🍊 除了进行串的传送之外，完成串操作指令后，<font color="blue">硬件还会自动完成其他操作</font>

#### 隐含操作数

🍊 <font color="blue">隐含操作数</font>

* **源串**
  * 默认存放地址`DS:SI`
* **目的串**
  * 默认存放地址`ES:DI`
* **串长度**
  * 存放在`CX`寄存器中

#### 完成串操作后

🍊 完成串传送，操作后，<font color="blue">硬件会自动完成</font>以下操作，【不需要程序员指定

* 修改`SI` & `DI`寄存器(偏移)，以指向下一个串元素
* 判断是否使用重复前缀，如使用，则`CX := CX - 1`

### 串传送方向: DF标志位 & STD/SLD

![](/static/2020-06-29-22-19-32.png)

> 通过**STD/CLD控制类指令，修改DF标志位，**用于设置**串传送方向**

![](/static/2020-06-29-23-55-45.png)

🍊 `CLD`指令，设置`DF=0`

* 从<font color="blue">源串低地址</font>开始传送
* `SI`&`DI`<font color="blue">自动增量</font>修改

🍊 `STD`指令，设置`DF=1`

* 从<font color="blue">源串高地址</font>开始传送
* `SI`&`DI`<font color="blue">自动减量</font>修改

#### 串传送方向: 目的

🍊 解决源串&目的串可能重叠的问题

![](/static/2020-06-30-15-41-30.png)

### 扩展: “最长指令”

![](/static/2020-06-30-20-09-34.png)

🍊 说明

* `LOCK`: 指令前缀
* `ADD`: 功能码
* `ES`: 强制指定存储单元在附加段(默认在数据段)
  * 存储单元地址由`EAX,ECX,立即数`计算后与<font color="blue">段基址移位</font>相加得到

🍊 指令编码共`15B`, 可认为是一条最长的`x86`指令

## MIPS体系结构

> MIPS是**精简指令系统的代表**，采用**与x86相反**的设计理念

🍬 MIPS寄存器编号用`$`符进行标记

### MIPS设计者&RISC先驱

![](/static/2020-07-02-13-24-14.png)

* 领导`RISC`微处理器研究小组
  * 相对`RISC`(精简指令系统计算机)，先前的计算机系统，如`x86`都称为`CISC`(复杂指令系统计算机)
* 之后创立MIPS计算机系统公司，**引领RISC精简指令系统潮流**

🍬 目前MIPS不再应用于计算机产品中，而是广义计算设备

* 如数字电视、游戏机、网络设备等

### MIPS指令的发展

![](/static/2020-07-02-14-03-03.png)

* 第一代`MIPS I`
  * `32`bit，85年推出对应处理器`R2000`
* 第二代`MIPS II`
  * `32`bit, 90年推出`R3000`处理器
* 第三代`MIPS III`
  * 扩展到`64`bit'，92年`R4000`
* 第四代`MIPS IV`
  * `64`bit, 94年进一步升级`R8000`
* 第五代`MIPS V`
  * 96年，`MIPS5`没有对应的处理器
* <font color="blue">99年，MIPS指令系统进行较大调整</font>
  * 基于`MIPS2`添加了`MIPS3,4,5`部分特性，形成了`MIPS32`
* <font color="blue">99年，以`MIPS5`为基础</font>
  * 推出`MIPS64`指令系统

#### MIPS设计指导思想

![](/static/2020-07-02-14-04-37.png)

🍊 MIPS全称

> Microprocessor without Interlocked Piped Stages
>
> 可看出, 指导思想是: **希望指令的设计能让微处理器运行更快，性能更好**

* 一个，<font color="blue">流水线不会互锁的微处理器</font>
  * <font color="purple">流水线</font>: 现代CPU为提高性能而采用的一项技术
  * <font color="purple">互锁</font>: **导致流水线性能降低的一个重要因素**

🍊 主要关注点

* **减少指令类型**
  * MIPS系统中，<font color="blue">指令总数很少</font>
* **降低指令复杂度**
  * MIPS系统中，<font color="blue">每条指令都比较简单</font>

🍊 基本原则

> A simpler CPU is a faster CPU

* 用一个非常简单的CPU(指令简单)来支持这样的指令系统
* CPU越简单运行越快

### MIPS指令主要特点: 如何实现

🍊 MIPS指令如何体现其设计思想？

* <font color="blue">MIPS固定指令长度</font> - <font color="red">32 bit(1 word=4B)</font>
  * 固定指令长度，<font color="blue">大大简化从存储器取指令</font> (x86指令变长，无法提前确定指令长度 )
* 采用<font color="blue">简单寻址模式</font>
  * 相比x86的复杂寻址模式, <font color="purple">虽然给编程带来不便</font>，但<font color="blue">大大简化CPU访问存储器的控制逻辑，简化从存储器取操作数</font>
* <font color="blue">指令数量少，功能简单</font>
  * <font color="red">一条指令只完成一个操作</font>，(x86一条指令往往完成丰富功能)
  * <font color="red">简化指令执行过程，可以实现指令并行执行技术</font>(从而提高CPU性能)
* <font color="blue">只允许`LOAD`&`STORE`指令访问存储器</font>
  * 不允许类似x86的算术指令访问存储，如`ADD AX,[3000H]`

🍬 注意MIPS这些特点，让<font color="blue">直接使用MIPS指令进行编程变得非常困难</font>

* <font color="red">进行高效MIPS程序编程，需要优秀编译器支持</font>

### MIPS指令示例(运算指令)

#### MIPS加法

🍊 加法指令

![](/static/2020-07-02-15-34-53.png)

* 格式
  * `add a, b, c`
* 操作
  * 将b&c求和，结果存入a

 🍬 注意: <font color="red">以上指令操作数都不可以是存储器操作数</font>

 ---

### MIPS指令示例(访存指令)

![](/static/2020-07-02-15-52-24.png)

### MIPS通用寄存器(32个,32bit)

🍊 共32个，每个位宽32bit

🍊 编写汇编程序时，可使用<font color="blue">数字/名称表示MIPS寄存器</font>

![](/static/2020-07-02-16-56-53.png)

* 1~31的寄存器加上`$`编号进行指示
  * 同时每个寄存器还可用<font color="blue">符号名称表示</font>
* 每个寄存器约定了<font color="blue">特定用途</font>
  * 如`$8~$15`又称`$t0~t07`，用于<font color="blue">保存临时变量</font>
  * `$1`又称`$at`，专门<font color="blue">给汇编器使用</font>

#### 通用寄存器使用示例

🍊 编写汇编程序时，可使用<font color="blue">数字/名称表示MIPS寄存器</font>

![](/static/2020-07-02-17-36-19.png)

## MIPS指令简介

### MIPS指令基本格式

![](/static/2020-07-03-15-05-56.png)

* **R型**
  * 寄存器型
* **I型**
  * 立即数型
* **J型**
  * 转移型(无条件)

---

#### 不同维度指令分类

![](/static/2020-07-03-15-23-49.png)

🍊 横轴

* 指令格式
  * **R型**
  * **I型**
  * **J型**

🍊 纵轴

* 指令功能类型
  * 运算指令
  * 访存指令
  * 分支指令

### R型指令格式 & 示例

![](/static/2020-07-07-22-26-41.png)

🍊 R型指令格式包含`6`个域

* 2个`6-bit`域，可表示`0~63`数
* 4个`5-bit`域, 可表示`0~31`数

🍬 高 & 低 6bit

* `opcode`域 - 用于指定指令类型
* `funct`域
* 所有R型指令，`opcode=0`
* 其他R型指令需要`funct`域指定，所以实际R型指令有`12`bit操作码

---

🍬 中间为4个5bit域，可表示\(2^5=32\)个通用寄存器,即`0~31`

![](/static/2020-07-07-22-27-21.png)
![](/static/2020-07-07-22-27-58.png)

* `rs` - source register
  * <font color="blue">指定第一个源操作数所在的寄存器编号</font>
* `rt` - target register
  * <font color="blue">指定第二个源操作数所在的寄存器编号</font>
* `rd` - destination register
  * <font color="blue">指定目的操作数(保存结果)的寄存器编</font>
* `shamt` - shift amount
  * <font color="blue">指定移位指令，进行移位操作的位数</font>
  * `5`**bit域可表示**`0~31`**的移位位数**, (对于`32`bit，更多移位没有实际意义)
  * <font color="red">非移位指令，该域设为0</font>

---

🍙 如何通过汇编指令描述，得到**MIPS二进制编码**?

![](/static/2020-07-07-22-25-35.png)

🍊 `add $8,$9,$10`

* 通过查询MIPS指令编码表，得到:
  * `opcode=0` - 加法指令opcode域
  * `funct=32` - 加法指令funct域
  * `shamt=0` - 非移位指令
* 通过指令操作数得到:
  * `rd=8` - 目的操作数desination register
  * `rs=9` - 第一个源操作数source register
  * `rt=10` - 第二个源操作数target register

🍙 最后，<font color="blue">将各个域的数值转化成二进制数</font>，填写至对应位置

* CPU进行这样的指令编码也非常容易

### I型指令的格式 & 示例(addi)

![](/static/2020-07-08-15-34-13.png)

🍙 <font color="blue">R型指令</font>中只有一个`5bit`域用于表示立即数

* range from `0~31`，<font color="blue">常用的立即数远大于这个范围，因此需要新的指令格式</font>

🍬 I型指令大部分域与R型指令<font color="blue">相同</font>

---

![](/static/2020-07-08-21-21-47.png)
![](/static/2020-07-08-21-22-30.png)

* `opcode`
  * 用于指定指令的操作类型，<font color="blue">没有`funct`域</font>
  * <font color="green">不同I型指令,opcode域不同</font>
* `rs` - source register
  * 指定<font color="blue">第一个源操作数</font>所在的寄存器编号
* `rt` - target register
  * 指定用于<font color="blue">保存运算结果的目的操作数</font>寄存器编号
  * 对于某些指令，指定<font color="blue">第二个源操作数</font>所在的寄存器编号
* `immediate` - 16bit
  * 可表示2^16个不同数值
  * 对于访存指令，如`lw rt,imm(rs)`, 通常可以<font color="green">满足访存地址偏移量</font>的需求`(-32768~+32768)`【±32K空间，2^15B】
  * 对于运算指令，如`addi rtm,rs,imm`，无法满足全部要求，但<font color="green">大多数时候可以满足</font>

---

![](/static/2020-07-08-21-31-14.png)

🍊 `addi $21,$22,-50` # *$21=$22+(-50)*

* 与add指令不一样(操作数必须都为寄存器)，其中一个源操作数为立即数

### 分支指令

![](/static/2020-07-08-21-33-51.png)

> **改变控制流的指令**，相当于x86中的转移指令

🍊 MIPS分支指令的分类

![](/static/2020-07-08-21-44-43.png)

* <b>conditional branch - 条件分支(i型)</b>
  * <font color="blue">根据比较的结果改变控制流</font>
  * branch if equal(`beq`)
  * branch if not equal(`bne`)
* <b>unconditional branch - 非条件分支(j型)</b>
  * <font color="blue">无条件地改变控制流</font>
  * jump(`j`)

#### 条件分支指令(I型)

![](/static/2020-07-08-22-27-39.png)

🍊 条件分支

* `beq rs,rt,imm` # *opcode=4*
* `bne rs,rt,imm` # *opcode=5*

🍊 以`beq`指令为例

* 格式：`beq reg1,reg2,L1`
  * 前两个为寄存器操作数
  * 最后一个为<font color="blue">存储器地址(立即数)</font>
* CPU判断`rs==rt`是否相等
  * <font color="blue">相等，跳转到`L1`所指向存储器单元取出下条指令</font>

🍬 注意，与x86转移指令不同，<font color="red">MIPS无标志寄存器`FLAGS`</font>

* 在一条指令内，进行比较&完成转移
* *MIPS主旨: 流水线不会互锁*，因此避免不同指令间的互相影响(标志位可能产生的)

#### 寻址模式: PC相对寻址(条件分支I型)

![](/static/2020-07-11-11-56-33.png)

> MIPS架构的寻址模式有**寄存器寻址、立即数寻址、寄存器相对寻址和PC相对寻址4种**

![](/static/2020-07-09-20-47-15.png)

---

🍬 地址对齐

> RISC下使用访存指令/写入数据单元时，**目标地址**必须是**所访问数据单元字节数的整数倍**
>
> RISC对齐要求严格，非对齐造成访问性能损失

🍬 <font color="blue">为什么分支指令偏移量需要左移2bit?</font>

* 转换为字节地址偏移量
* 已知MIPS指令固定4B，需要对齐，16bit的偏移量实际指需要跳转的**指令字数**【不是指需要跳转的字节数】，而PC按字节寻址，需要单位统一，因此`×4==<<2`

🍬 <font color="red">条件分支指令(I型)的目标地址范围</font>，如何充分发挥`16`bit(立即数/存储地址)?

![](/static/2020-07-10-19-33-27.png)

* 如果以`PC`寄存器(MIPS32bit)为基准，`16`bit位移量可表示`±2^15word=±32KB`(注意符号位，此时字长单位word)
* MIPS指令长度固定为`32bit(1word)`
  * 每条指令一定在四个字节对齐的地方，即**最低两位肯定为0（偏移量左移2位后）**

🍊 目标地址计算方法

![](/static/2020-07-11-11-01-04.png)

🍬 注意不要混淆**寻址空间范围&寻址空间大小，按字寻址&按字节寻址**

🍬 针对分支出现需要跳转时，为什么`+4`
![](/static/2020-07-11-10-06-06.png)

* 硬件自动完成

![](/static/2020-07-11-11-36-17.png)

---

🍊 条件分支指令的示例

![](/static/2020-07-08-22-30-34.png)

#### 寻址模式: 绝对寻址(非条件分支J/R型)

![](/static/2020-07-11-11-56-33.png)

🍊 J型 - 不需要条件判断，扩大目标地址范围(寻址范围)

* 理想情况，直接使用`32bit`地址
  * 冲突: MIPS指令长度固定`32bit`，`opcode(6bit)`

![](/static/2020-07-11-12-08-00.png)

🍊 R型 - 如何跳转到更远的地址?

![](https://img-blog.csdnimg.cn/20200202003443455.png)

* **2次调用j指令**以扩大范围(不方便)
* 还可采用<font color="blue">间接转移指令`jr rs`</font>
  * 将要转移的目标地址存入寄存器，从而可使用`32bit`目标地址，通过R型指令实现(占用其中一个寄存器位域，新增一种`funct`编码)

## Exercise: MARS