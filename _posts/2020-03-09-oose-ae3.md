---
layout: post
title: OOSE AE3
date: 2020-03-09
excerpt: "è½¯å·¥è¯¾é¢˜ä½œä¸š - Visitors Design Pattern with JavaParser"
tags: [è¯¾é¢˜, code, è½¯ä»¶å·¥ç¨‹, 2020, oose]
feature: https://previews.123rf.com/images/karpenkoilia/karpenkoilia1709/karpenkoilia170900117/86423976-modern-line-web-concept-for-programming-linear-web-banner-for-coding-.jpg
comments: true
---

* ç›®å½•
{:toc}

## Objective

ğŸŠ ç›®æ ‡
> In this coursework, you will learn how to use the software framework called JavaParser
and its documentation to build a static analyser. You will also understand how the visitor
design pattern is applied in the implementation of such framework. This objective will be
evaluated based on your ability to extend the VoidVisitorAdapter in JavaParser. This
is to implement concrete detectors that traverses an Abstract Syntax Tree representation
of a program code using the visitors design pattern.

æœ¬è¯¾é¢˜ï¼Œå­¦ä¹ `JavaParser`è½¯ä»¶æ¡†æ¶åŠå…¶æ–‡æ¡£ï¼Œæ„å»ºä¸€ä¸ªé™æ€åˆ†æå™¨ã€‚ç†è§£å¦‚ä½•åº”ç”¨è®¿é—®è€…æ¨¡å¼å®ç°è¯¥æ¡†æ¶ã€‚æ ¹æ®`VoidVisitorAdapter`ç±»çš„æ‰©å±•è´¨é‡è¿›è¡Œè¯„ä¼°ã€‚ä½¿ç”¨è®¿é—®è€…æ¨¡å¼ï¼Œå®ç°å…·ä½“æ£€æµ‹å™¨éå†ç¨‹åºæŠ½è±¡è¯­æ³•æ ‘ã€‚

## Setup

ğŸŠ é…ç½®

> Create a simple maven project without archtype using eclipse IDE 
> 
> åˆ›å»ºMavené¡¹ç›®:
>  
> - Check create a simple project (skip archetype selection).
> 
> - Enter Group Id = oose.workshop3
> - Artifact Id= workshop3
> - Name = workshop3
> - Click on pom.xml file and Include the following dependency:

```xml
<dependencies>
<dependency>
<groupId>com.github.javaparser</groupId>
<artifactId>javaparser-core</artifactId>
<version>3.12.0</version>
</dependency>
</dependencies>
```

> Create a package called **detectors** to contain the four java classes for Tasks 1 and
> 2 highlighted below.
> 
> åˆ›å»ºåŒ…`detectors`ï¼ŒåŒ…å«TASK1&2ä¸­çš„4ä¸ªjavaç±»

ğŸ¬ å¯å‚è€ƒï¼Œ[å¦‚ä½•åˆ›å»ºç®€å•mavené¡¹ç›®](https://www.javaguides.net/2018/11/how-to-create-simple-maven-project-in.html)

---

## Task 1

> A control flow statement in a method is characterised as a **useless control flow** continues onto the same place regardless of whether or not the branch is taken. For example, having an empty statement block for an if
> statement:

æ— ç”¨æ§åˆ¶æµè¯­å¥
ğŸ¬ æœ¬è¯¾é¢˜åªæ£€æµ‹**ç©ºè¯­å¥å—**`empty statements`ï¼Œæ— ç”¨æ§åˆ¶æµ

```java
/* ifè¯­å¥ï¼Œç©ºç™½ä»£ç å— */
if (argv.length==1);
System.out.println(argv[0]);

if (argv.length==0){
    // TODO: handle this case
}
```

```java
// Examples of useless control flow in switch and if, else statements

switch(operator) {
    case '+':
        System.out.println("hello");
        break;
    case '-':         //useless control flow
    case '/':        //useless control flow
}

//Similar if you have an if, else statement:

if(x==y){
     y=0;
}
else if(x>0){       //useless control flow
}
else{                //useless control flow
}
```

> There are other forms of control flows such as **for, while, do... while and switch**. Using the visitors design pattern, create the class `UselessControlFlowDetector.java` that detects useless control flow in java program code. Create a container class called `Breakpoints.java` to collect this observed behaviour as the visit method(s) implemented in detector transverses through the program structure. Finally, implement the class `Driver.java` that instantiates the detector and provides it with program code to operate on. `Driver.java` should print each detected pattern to command line in the format:
>
> æœ‰å…¶ä»–å½¢å¼çš„æ§åˆ¶æµç»“æ„: **for, while, do...while, switch**.ä½¿ç”¨è®¿é—®è€…è®¾è®¡æ¨¡å¼ï¼Œ
> 1. åˆ›å»º`UselessControlFlowDetector.java`æ£€æµ‹å™¨(è®¿é—®è€…)ï¼Œæ£€æµ‹æ— ç”¨æ§åˆ¶æµç»“æ„ã€‚
> 2. åˆ›å»ºå®¹å™¨ç±»(å¯¹è±¡ç»“æ„)`Breakpoints.java`ï¼Œå­˜æ”¾éå†ASTä¸­ç›¸å…³èŠ‚ç‚¹ï¼Œè°ƒç”¨`visit(...)`æ–¹æ³•å¾—åˆ°çš„è¡Œä¸º
> 3. å®ç°`Driver.java`ç±»(å®¢æˆ·ç«¯)ï¼Œåˆå§‹åŒ–æ£€æµ‹å™¨ï¼Œæä¾›ä»£ç æ“ä½œã€‚æ‰“å°æ ¼å¼å¦‚ä¸‹ï¼š

```java
Useless Control Flows:
className =?, methodName =?, startline =?, endline =?
className =?, methodName =?, startline =?, endline =?
```

## Task 2

> Polymorphic recursion is a property of a program code where the parameter types of a method may change with each recursive invocation. Hence, in detecting a function that implements polymorphic recursion, the number of parameters and their types does not matter. For example, the methods named method1 in Test.java below implement polymorphic recursion.
>
> å¤šæ€é€’å½’: æ¯æ¬¡é€’å½’è°ƒç”¨ï¼Œæ–¹æ³•å‚æ•°ç±»å‹æ”¹å˜ã€‚æ£€æµ‹å¤šæ€é€’å½’å‡½æ•°ï¼Œä¸è€ƒè™‘å‚æ•°ç±»å‹&å‚æ•°æ•°é‡ã€‚ä¾‹å¦‚`Test.java`ä¸­çš„å¤šæ€é€’å½’å‡½æ•°`method1`.

```java
/* æ³¨æ„æ­¤ä¾‹å­ä¸éœ€è¦æ£€æŸ¥æ— é™é€’å½’æ ˆæº¢å‡ºï¼Œåªæ‰“å°å¤šæ€é€’å½’ç›¸å…³ä¿¡æ¯ */
class Test{
    int x;
    public void method1(String args[]){
        method1(args);
        System.out.println(args);
    }
    // overload
    public void method1(String args[],int x, Test t){
        this.x = 1;
        method1(args);
    }
}
```

> Using the visitors design pattern, create the class RecursionDetector.java that detects polymorphic recursion in java program code. Use the container Breakpoints.java to collect observed recursive behaviour as the visit method(s) implemented in detector transverses through the program structure. Also extend Driver.java to instantiate this detector and provide it with program code to operate on. Finally, the output of Driver.java for detected behaviour should be similar to Task 1, by printing the class and method name, and also start and end line of observed pattern to command line. in the format:
>
> ä½¿ç”¨è®¿é—®è€…è®¾è®¡æ¨¡å¼ï¼Œ
> 1. åˆ›å»º`RecursionDetector.java`ç±»(è®¿é—®è€…)æ£€æµ‹ç¨‹åºä¸­å¤šæ€é€’å½’ã€‚
> 2. ä½¿ç”¨å®¹å™¨ç±»(å¯¹è±¡ç»“æ„)`Breakpoints.java`ç”¨äºéå†è®¿é—®ASTå„å…ƒç´ ï¼Œå¹¶è°ƒç”¨`visit(...)`è·å–è¡Œä¸º
> 3. å®ç°`Driver.java`ç±»(å®¢æˆ·ç«¯)ï¼Œåˆå§‹åŒ–æ£€æµ‹å™¨ï¼Œæä¾›ä»£ç æ“ä½œã€‚æ‰“å°æ ¼å¼(ç±»åï¼Œæ–¹æ³•åï¼Œæ–¹æ³•å¼€å§‹è¡Œï¼Œæ–¹æ³•ç»“æŸè¡Œ)å¦‚ä¸‹ï¼š

```java
Polymorphic Recursions:
className =?, methodName =?, startline =?, endline =?
className =?, methodName =?, startline =?, endline =?
```

---

## Hints

- å¯ä»¥å‚è€ƒ[JavaParser's documentation](https://www.javadoc.io/doc/com.github.javaparser/javaparser-core/3.12.0/index.html) & ç”µå­ä¹¦[JavaParser:Visited](https://leanpub.com/javaparservisited)
- `AstVisualizer`å·¥å…·å¯è§†åŒ–AST
- `Calculator.java`ç±»ç”¨äºæµ‹è¯•solutions.å‡è®¾æ— åµŒå¥—ç±»ã€‚
- é¡¹ç›®ä»£ç &æ–‡æ¡£&æ»¡è¶³`SOLID`åŸåˆ™çš„ç¨‹åº¦

## Deliverables

1. å‹ç¼©mavené¡¹ç›®(task1&2).`UselessControlFlowDetector.java`,
`RecursionDetector.java`, `Breakpoints.java` and `Driver.java` é¡¶éƒ¨æ ‡æ˜name&guid

2. é¡¹ç›®æ‰“åŒ…æˆ`jar`

---

## æ€è·¯

ä½¿ç”¨ä»APIæ–‡æ¡£æå–ä¼šç”¨åˆ°çš„ç±»&åŒ…ï¼Œç±»å&æ–¹æ³•å&æ–¹æ³•ä½“èµ·å§‹ï¼Œç»“å°¾ç›¸å…³

- `JavaParser`
  - `parse(File file)`è¿”å›`static CompilationUnit`

- `CompilationUnit`
  - `getModule`
    - è¿”å›`Optional<ModuleDeclaration>`ï¼Œ`ModuleDeclaration.getName()`
  - `getClassByName(String className)`é¡¶éƒ¨ç±»å£°æ˜
    - è¿”å›`Optional<ClassOrInterfaceDeclaration>`
- `ClassOrInterfaceDeclaration.getNameAsString()`

- `MethodDeclaration`
  - `getBody() `è¿”å›`Optional<BlockStmt>`
    - `	getStatements() ` è¿”å›`NodeList<Statement>`
  - `getDeclarationAsString(boolean includingModifiers, boolean includingThrows, boolean includingParameterName)`

- `Optional<BlockStmt>` è¯­å¥å—ï¼Œå¯ä»èŠ‚ç‚¹è·å¾—èŠ‚ç‚¹ä½“è·å¾—
  - `isPresent()` æ˜¯å¦å­˜åœ¨ï¼Œæ˜¯å¦ä¸ºç©º
  - `getStatements()` è·å–èŠ‚ç‚¹ä½“ä¸­æ‰€æœ‰è¯­å¥ï¼Œå½¢æˆèŠ‚ç‚¹åˆ—è¡¨`NodeList<Statement>`

- `Statement`ä»æ–¹æ³•ä½“çš„è¯­å¥å—`BlockStmt`ä¸­è·å¾—
  - `DoStmt` do..whileè¯­å¥
  - `ForEachStmt` & `ForStmt` forå¾ªç¯
  - `IfStmt`
  - `SwitchStmt` & `SwitchEntry`
  - `WhileStmt.getBody()`
  - `isEmptyStmtï¼ˆï¼‰` ç”¨äºåˆ¤æ–­æ§åˆ¶æµæ˜¯å¦ä¸ºç©ºï¼Œ
  - `BlockStmt.getStatements()`è¿”å›èŠ‚ç‚¹åˆ—è¡¨`NodeList<Statement>`
  - `getChildrenNodes()`è¿”å›å…¨éƒ¨å­èŠ‚ç‚¹çš„åˆ—è¡¨`List<Node>` 

- 

ğŸ¬ é™¤äº†ä»¥ä¸Šåˆ¤æ–­æ§åˆ¶æµï¼Œå†è¿›ä¸€æ­¥åˆ¤æ–­æ§åˆ¶æµå†…**æ˜¯å¦è¯­å¥ç›´æ¥ä¸ºç©ºï¼Œæ˜¯å¦è¯­å¥å—ä¸ºç©ºifèŠ‚ç‚¹.getBody.isPresent()**ï¼Œ~~è¿˜éœ€è¦åˆ¤æ–­æ˜¯å¦åªå«æœ‰**æ— ç”¨æ³¨é‡Š**çš„æƒ…å†µ~~
ğŸ¬ å¦‚æœæ§åˆ¶æµç»“æ„çš„è¯­å¥å—`BlockStmt`æ— å­èŠ‚ç‚¹ï¼Œåˆ™æ— ç”¨
ğŸ¬ å¦‚æœæ§åˆ¶æµç»“æ„çš„è¯­å¥å—`BlockStmt`å­èŠ‚ç‚¹**ä»…æœ‰**`EmptyStmt`ç©ºè¯­å¥ï¼Œåˆ™æ— ç”¨

- `Node`
  - `findAll(Class<T> nodeType)`
  - `node.getSimpleName()`ç±»åï¼ŒèŠ‚ç‚¹å
  - `node.getClass()`ç±»å
  - `node.getMembers()`ç±»æˆå‘˜ï¼ŒåŒ…æ‹¬æ–¹æ³•
  - `getRange().get().begin.line`Rangeå¯¹è±¡è®°å½•ä½ç½®ä¿¡æ¯(è¡Œå·)
  - `getChildrenNodes()`è·å–å­èŠ‚ç‚¹åˆ—è¡¨


- `VoidVisitorAdapter`ç»§æ‰¿ä½¿ç”¨è¯¥é€‚é…å™¨è®¿é—®è€…ï¼Œä¸ç›´æ¥è¦†å†™åº•å±‚è®¿é—®è€…æ–¹æ³•

![](/static/2020-03-10-13-48-15.png)

## åˆ©ç”¨APIè¾…åŠ©å¯è§†åŒ–AST

![](/static/2020-03-11-06-33-04.png)
![](/static/2020-03-11-06-40-27.png)
- æ— ç”¨`if-else`æ§åˆ¶æµï¼Œæ§åˆ¶ç»“æ„ä½“ä¸ºç©º

![](/static/2020-03-11-16-28-56.png)
- æ— ç”¨`switch`ç»“æ„ï¼Œ`SwitchEntryStmt`ä¸ªæ•°& åŠå…¶å­èŠ‚ç‚¹ä¸ªæ•°`<=1`
- `SwitchStmt`å­èŠ‚ç‚¹`<=1`

![](/static/2020-03-11-18-23-32.png)
- æ— ç”¨`for`ç»“æ„ï¼Œæ— å¾ªç¯ä½“`EmptyStmt`

![](/static/2020-03-11-06-46-13.png)
![](/static/2020-03-11-06-37-22.png)
- æ­¤å›¾å¯ä»¥çœ‹å‡ºæ¥ä¸éœ€è¦åˆ¤æ–­æ³¨é‡Š

![](/static/2020-03-11-21-46-51.png)
- å¤šæ€é€’å½’ï¼Œä¸è€ƒè™‘å‚æ•°ç±»å‹ï¼Œå‚æ•°æ•°é‡(æœ€ååªæ¯”è¾ƒæ–¹æ³•å)

## Debug Record

ğŸ™ åªè®°å½•éƒ¨åˆ†

ğŸ¬ Useless Control Flow ç›¸å…³
1. è·å¾—æ–¹æ³•ä½“`BlockStmt`ä¸­ï¼Œè·å–æ‰€æœ‰è¯­å¥èŠ‚ç‚¹å`NodeList<Statement>`ã€‚è¿›è¡Œæ§åˆ¶æµè¯­å¥åˆ¤æ–­ã€‚åç»­åˆ¤æ–­æ§åˆ¶æµç»“æ„çš„å­èŠ‚ç‚¹ç±»å‹å¤±è´¥ã€‚æ— æ³•æ‰§è¡Œ`Statement`å¼ºåˆ¶è½¬æ¢ï¼Œå› ä¸ºå­˜åœ¨`Expression`èŠ‚ç‚¹ã€‚
![](/static/2020-03-11-12-54-24.png)
- æ‰¾åˆ°æ–¹æ³•å®ç°: åˆ¤æ–­æ§åˆ¶æµç»“æ„çš„`BlockStmt`åŠ`childrenNodes`ç±»å‹ï¼Œä¼˜å…ˆç»Ÿä¸€åˆ¤æ–­ï¼Œ**æ³¨æ„ï¼ŒåµŒå¥—æƒ…å†µå‡ºç°**

2. åˆ¤æ–­`BlockStmt`çš„çˆ¶èŠ‚ç‚¹æ˜¯å¦ä¸ºæ§åˆ¶æµç»“æ„
- æœ€åé€šè¿‡çˆ¶èŠ‚ç‚¹ç±»åä¸å·²çŸ¥æ§åˆ¶æµç»“æ„ç±»åè¿›è¡Œåˆ¤æ–­
  - å› ä¸ºçˆ¶èŠ‚ç‚¹`Node`ç±»å‹æœ‰é™åˆ¶

3. pitfalls checkï¼Œå¾ˆçƒ¦ï¼Œä¸»è¦æ£€æµ‹é¡¶éƒ¨æ§åˆ¶æµä¸º`EmptyStmt`æƒ…å†µã€‚Switchç»“æ„æ¯”è¾ƒç‰¹æ®Šï¼Œ`Entry`ä¸ªæ•°ä¸º1ä¸ä¸€å®šä¸ºuseless control flowï¼Œä¸»è¦çœ‹entryä¸‹é¢èŠ‚ç‚¹æ˜¯ä»€ä¹ˆã€‚

4. æœŸé—´å¿˜äº†æ£€æµ‹æ³¨é‡Šï¼Œä½¿ç”¨ä¸€ä¸ªå˜é‡è¿›è¡Œéæ³¨é‡ŠèŠ‚ç‚¹çš„è®¡æ•°ï¼Œå¦‚æœå­èŠ‚ç‚¹åªå«æœ‰æ³¨é‡Šï¼Œåˆ™æ— ç”¨ã€‚åº”è¯¥è¿˜èƒ½ç®€åŒ–å†™å‰”é™¤å†—ä½™ä»£ç ï¼ˆå› ä¸ºç»•æ™•äº†ï¼Œæ”¾å¼ƒï¼‰

---

## Solution

ğŸŠ`UselessControlFlowDetecotr.java`

```java
public class UselessControlFlowDetector extends VoidVisitorAdapter<List<Breakpoints>> {

	@Override
	public void visit(MethodDeclaration md, List<Breakpoints> collector) {
		super.visit(md, collector);

		// if current method has body, operating on it or we pass the method
		Optional<BlockStmt> methodBody = md.getBody();
		if (methodBody.isPresent()) {
			// fields for checking whether parent node type is control flow structure
			String[] controlFlowNamea = { "IfStmt", "DoStmt", "ForEachStmt", "ForStmt", "SwitchStmt", "WhileStmt" };
			List<String> controlFlowName = Arrays.asList(controlFlowNamea);
			// record the nodes that needed to be put in container
			List<Node> nodeList = new ArrayList<>();
			// get all the BlockStmt children of method nodes
			List<BlockStmt> blockStatements = md.findAll(BlockStmt.class);
			List<EmptyStmt> emptyStatements = md.findAll(EmptyStmt.class);
			List<SwitchStmt> switchStatements = md.findAll(SwitchStmt.class);

			// if found the BlockStmt inside the method, checking whether the parent node is
			// control flow structure(this would not apply on switch)
			for (BlockStmt s : blockStatements) {
				// fields for checking the children nodes existence and parent node type
				// if there doesn't exist the children nodes, the control flow is useless
				List<Node> blockChildren = s.getChildNodes();
				Node blockParent = (s.getParentNode()).get();
				String blockParentClassName = blockParent.getClass().getSimpleName();

				if ((controlFlowName.contains(blockParentClassName))) {
					// count variable is used for counting the nodes excepting Comment
					int count = 0;
					for (Node node : blockChildren) {
						if (!(node instanceof Comment)) {
							count++;
						}
					}
					// if count==0, means that this block only has Comment children nodes
					// or doesn't have children nodes which is considered useless
					if (count == 0) {
						nodeList.add(s);
					}
				}
			}

			// if found the EmptyStmt inside the method, checking whether the parent node is
			// control flow structure(this would not apply on switch)
			for (EmptyStmt e : emptyStatements) {
				Node blockParent = (e.getParentNode()).get();
				String blockParentClassName = blockParent.getClass().getSimpleName();
				if ((controlFlowName.contains(blockParentClassName))) {
					nodeList.add(blockParent);
				}
			}

			for (SwitchStmt s : switchStatements) {
				List<SwitchEntry> switchChildren = s.findAll(SwitchEntry.class);
				// if the switch structure does not have specified body, it is useless
				if (switchChildren.size() < 1) {
					nodeList.add(s);
				} else {
					// checking the entries of switch structure,
					// if there are no statements related to entry, it is useless
					for (SwitchEntry e : switchChildren) {
						List<Node> entryChildren = e.getChildNodes();
						int count = 0;
						for (Node n : entryChildren) {
							if (n instanceof Statement) {
								count++;
							}
						}
						if (count == 0) {
							nodeList.add(e);
						}
					}
				}
			}

			// put the nodes into container Breakpoints
			nodeList.forEach(n -> {
				String methodName = md.getName().asString();
				String className = ((NodeWithSimpleName<MethodDeclaration>) md.getParentNode().get()).getNameAsString();
				int begin = n.getRange().get().begin.line;
				int end = n.getRange().get().end.line;
				Breakpoints report = new Breakpoints(className, methodName, begin, end);
				collector.add(report);
			});
		}
	}
}
```

ğŸŠ`RecursionDetector.java`

```java
public class RecursionDetector extends VoidVisitorAdapter<List<Breakpoints>> {

	@Override
	public void visit(MethodDeclaration md, List<Breakpoints> collector) {
		super.visit(md, collector);

		// find all the MethodCallExpression nodes of MethodDeclaration
		List<MethodCallExpr> methodCallList = md.findAll(MethodCallExpr.class);
		// if current method body has call expression
		if (!methodCallList.isEmpty()) {
			// record the nodes that needed to be put in container
			List<Node> nodeList = new ArrayList<>();
			// fields for container and checking
			String methodName = md.getName().asString();
			String className = ((NodeWithSimpleName<MethodDeclaration>) md.getParentNode().get()).getNameAsString();

			for (MethodCallExpr each : methodCallList) {
				String callName = each.getName().asString();
				// check whether the method call itself
				if (callName.equals(methodName)) {
					nodeList.add(each);
				}
			}

			// put the nodes into container Breakpoints
			nodeList.forEach(n -> {
				int begin = n.getRange().get().begin.line;
				int end = n.getRange().get().end.line;
				Breakpoints report = new Breakpoints(className, methodName, begin, end);
				collector.add(report);
			});

		}
	}

}
```

ğŸŠ `Breakpoints.java`
```java
public class Breakpoints {
	private String className;
	private String methodName;
	private int begin;
	private int end;
	
	public Breakpoints(String className, String methodName, int begin, int end) {
		this.className = className;
		this.methodName = methodName;
		this.begin = begin;
		this.end = end;
	}

	@Override
	public String toString() {
		return "className=" + className + ", methodName=" + methodName + ", startline=" + begin + ", endline="
				+ end;
	}
}
```

ğŸŠ `Driver.java`
```java
public class Driver {
	
	// path of testing file that will be parsed
	private static final String FILE_PATH = "src\\main\\java\\detectors\\Calculator.java";

	public static void main(String[] args) {
		try {
			CompilationUnit cu = JavaParser.parse(new FileInputStream(FILE_PATH));
			// visitor container
			List<VoidVisitorAdapter<List<Breakpoints>>> visitorList = new ArrayList<>();
			// initialise the useless control flow detector
			UselessControlFlowDetector cfVisitor = new UselessControlFlowDetector();
			
			// initialise the recursion detector
			RecursionDetector prVisitor = new RecursionDetector();
			visitorList.add(cfVisitor);
			visitorList.add(prVisitor);
			
			visitorList.forEach(v->{
				List<Breakpoints> collector = new ArrayList<>();
				v.visit(cu,collector);
				if (v instanceof UselessControlFlowDetector) {
					System.out.println("Useless Control Flows:");
				}
				if (v instanceof RecursionDetector) {
					System.out.println("Polymorphic Recursions:");
				}
				collector.forEach(r->{
					System.out.println(r);
				});
			});

		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}
}

```

ğŸŠ æµ‹è¯•ç”¨è§£æç±»`Calculator.java`

```java
package detectors;

import java.util.Scanner;

/**
 * 
 * @author inah
 * This class contains utility functions for different calculator operations
 */
public class Calculator {

	public Calculator(){}

	public int add(int a, int b) {
		return a + b;
	}

	public int subtract(int a, int b) {
		return a - b;
	}

	public int multiply(int a, int b) {
		return a * b;
	}

	public int divide(int a, int b) {
		int value = -100000000;
		if (b == 0) {
			System.out.println("Error! Dividing by zero is not allowed.");
		} 
		else if(a==0) {

		}
		else {
			value =  a / b;
		}

		return value;
	}

	public int modulo(int a,int b){
		int value = -100000000;
		if (b == 0) {
			System.out.println("Error! Dividing by zero is not allowed.");
		} else {
			value = a % b;
		}
		return value;
	}

	public static int multiply2(int num1, int num2) {
		if (num1 == 0 || num2 == 0) {
			return 0;
		}
		else if(num2 > 0){
			return num1 + multiply2(num1, num2 - 1);
		}
		else{
			return -num1 + multiply2(num1, num2 + 1);
		}
	}

	public static void switchCalculator() {

		Scanner reader = new Scanner(System.in);
		System.out.print("Enter two numbers: ");

		double first = reader.nextDouble();
		double second = reader.nextDouble();

		System.out.print("Enter an operator (+, -, *, /): ");
		char operator = reader.next().charAt(0);

		double result;

		switch(operator)
		{
		case '+':
			result = first + second;
			break;

		case '-':
			result = first - second;
			break;

		case '*':
			result = first * second;
			break;

		case '/':
			result = first / second;
			break;
		default:
			System.out.printf("Error! operator is not correct");
			return;
		}

		System.out.printf("%.1f %c %.1f = %.1f", first, operator, second, result);
	}

	public void method1(String args[]){
		int x =1;		
		method1(args,x);
	}

	public void method1(String args[],int x){

	}
	
	public static int sumNTimes(int factor, int n) {
        int sum = 0;
		for(int i = 0; i <=n; i++) {
            sum = sum + factor;
		}
		
		return sum;
	}
}

```