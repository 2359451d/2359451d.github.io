---
layout: post
title: "DF Week1 - Numerical Basics"
date: 2020-10-05
excerpt: "data fundamentalsç¬”è®°"
tags: [å­¦ä¹ ç¬”è®°, data fundamentals, 2020, python]
feature: https://miro.medium.com/max/1400/1*gHamsYEMBoVIWbTbn3CQ-A.gif
comments: true
---

[reference: week_2_numerical_ii.pdf](https://moodle.gla.ac.uk/pluginfile.php/1241377/mod_folder/content/0/week_2_numerical_ii.pdf?forcedownload=1)

infomation is filteredï¼Œï¼Œå·²ç­›é€‰éƒ¨åˆ†ç”¨å¾—ä¸Šçš„

* ç›®å½•
{:toc}

## Outline

learned

* how IEEE 754 `float32` & `float64` numbers are represented
* how to represent infinity & `NaN`
  * how they are used
* what is **roundoff error**
  * how it tends to be caused?
* **comparision of floating point numbers**
* **machine epsilon(æœºå™¨ç²¾åº¦)**
  * definition
* **strided arrays**
  * how to index & do arithmetic operations
* memory(DRAM) arrays layout
* use of higer-rank tensors
  * (rank) high dimension tensors
* **reshape & reorder** higher-rank tensors
* use **einsum(çœå»æ±‚å’Œå¼ä¸­çš„æ±‚å’Œç¬¦å·) for basic operation**

## Integer

2 types

![](/static/2020-10-07-22-03-03.png)

* signed(2' complement stored in memory)
* unsigned(binary stored in memory)

ğŸŠ 64-bit system max support 64 bit word

* exceeds the bounds - overflow
  * sometimes wrap around
* numpy allows integer arrays, but generally not used

## Floating Point

float has some properties could cause **numerical issues**

### IEEE 754: how to represents float

IEEE 754 convention
![](/static/2020-10-07-23-21-38.png)
![](/static/2020-10-07-22-36-43.png)
![](/static/2020-10-07-22-40-48.png)

exponent part representation

![](/static/2020-10-07-22-46-48.png)
![](/static/2020-10-07-22-53-54.png)

example

![](/static/2020-10-07-23-00-16.png)
![](/static/2020-10-07-23-02-52.png)

---

![](/static/2020-10-07-23-13-52.png)

#### float & double

float32

* 32bit
* 4B
* **GPU** typically using float32, but also can process float64

float64

* 64bit
* 8B
* **desktop CPUs(x86)** have specialised float64 hardware

---

**exotic** floating point numbers

* **some GPUs** can do **very fast float16 operations**
* **precision is not critical**
* **unusal format(even float8)** of some specialised machine learning language

float 128 & 256

* **astronomical simulations**
* precision & tiny error very matters
* **numpy does not support 128 or 256**

ğŸ¬ IEEE754 also specifies **float-point decimals which are rarely used**

* excepting the case some specialised application(calculator)

### sign & exponent & mantissa

a float has 3 parts(integer)

* exponent
  * the magnitude of a number
* mantissa
  * the fractional part of a number

ğŸŠ **scientific notation(one digit before the point)**

* `[mantissa] * 10 ^ [exponent]`

`5340.2`

* `5.3402 * 10^3`
* `5.3402e3`

`0.00051`

* `5.1 * 10^-4`
* `5.1e-4`

### binary float

all operations are done on **base 2**, and binary float comprises of 3 parts

![](/static/2020-10-07-22-31-44.png)
![](/static/2020-10-07-22-31-33.png)

* sign
  * 1 bit
  * indicats if postive or negative
* exponent
  * signed integer
  * **how much shift** the mantissa by
* mantissa
  * unsiged integer
  * <font color="red">fractional part following the `1`</font>
* `sign * (1.[mantissa]) * (2^exponent)`

ğŸŠ example

* `5.0`(decimal) -> `101.0`(binary) -> `1.01 * 2^2`(scientific)
  * sign - `1`(s=0)
  * mantissa - `1.01`
  * exponent - `2`

#### leading one

leading `1` is inserted before the binary float's mantissa

* unecessary to represent this bit
  * mantissa always 1.0<=mantissa<2.0
  * so the mantissa's bit extends 1 bit

ğŸŠ IEEE 754 representation

* `float 32`
  * sign - 1bit
  * exponent - 8bit
  * mantissa - 23bit(0 fills backwards)
* <font color="red">Note that: exponents need to stored with the offset intermidate number `127` or `1023`</font>

ğŸŠ example

![](/static/2020-10-07-23-00-16.png)
![](/static/2020-10-07-23-02-52.png)

---

![](/static/2020-10-07-23-13-52.png)

## Binary representation of floats

the representation stored in memory could be split up into 3 parts

* **sign**
* **exponent**
* **mantissa**

ğŸŠ example

![](/static/2020-10-07-23-56-37.png)

* æ­¤ä¾‹mantissaä¸åº”è¯¥+1ï¼Œåº”è¯¥è¿˜åŸæˆ0.xxxxxxçš„å°æ•°ï¼Œæ— é™è¶‹è¿‘äº0

![](/static/2020-10-08-00-18-50.png)
![](/static/2020-10-08-00-18-38.png)
![](/static/2020-10-08-00-28-47.png)
![](/static/2020-10-08-00-31-11.png)
![](/static/2020-10-08-14-03-55.png)
![](/static/2020-10-08-14-05-47.png)
![](/static/2020-10-08-14-06-00.png)
![](/static/2020-10-08-14-06-33.png)
![](/static/2020-10-08-14-06-41.png)

### integers in floats

float64

![](/static/2020-10-08-14-16-00.png)

* integer from -2^53~2^53 is precisely representable

## Features of Floats

### float exceptions

sometimes can cause exceptions during calculations.

* exceptions occur at the **hardware level**

ğŸŠ 5ç§æ™®éçš„æµ®ç‚¹æ•°æ“ä½œå¼‚å¸¸ 5 standard floating point **exceptions**

* **invalid operations**
  * an operation without a defined real number result is attempted
  * like 0.0/0.0 or sqrt(-1.0)
  * trapped
* **division by 0**
  * may or may not be trapped
* **Overflow**
  * results exceeds the limit of the float point number
  * may or may not be trapped
* **underflow**
  * result is smaller than its smallest representable number
  * **rounded off to `0`**
  * untrapped
* **inexact**
  * computation would produce an inexact result due to rounding
  * untrapped

ğŸ¬ numpy trapæ‰€æœ‰å¼‚å¸¸ï¼ˆé™¤inexactï¼‰

![](/static/2020-10-08-14-33-27.png)

* ä½†é€šå¸¸åªæ‰“å°è­¦å‘Šï¼Œå¹¶ç»§ç»­æ“ä½œ
* ä¹Ÿå¯ä»¥é…ç½®æˆåœæ­¢æ‰§è¡Œ&æŠ›å‡ºå¼‚å¸¸

---

ğŸŠ å¼‚å¸¸ç±»å‹ exception type: an exception can be

* **trapped**
  * indicats the operation is problematic, **could halt or take other action**
  * é€šå¸¸invalid operation is 
* **untrapped**
  * **wont halt execution, but do some default operation**
  * like `/0` would output `âˆ` instead of halting
  * é€šå¸¸inexact & undeflow operation is trapped

## Special numbers: 0, inf, NaN

### +0 & -0

IEEE754æœ‰`Â±0`çš„è¡¨ç¤º

* `+0`
  * æœ‰signï¼Œexponentï¼Œmantissaéƒ¨åˆ†
* `-0`
  * æœ‰sign

+0ï¼Œ-0æ“ä½œ&å€¼å®Œå…¨ç›¸åŒï¼Œ

![](/static/2020-10-08-14-41-21.png)
![](/static/2020-10-08-14-42-26.png)

* é™¤äº†sign bit propagatingæ–¹å¼

### +âˆ and -âˆ

IEEE754æ˜¾å¼è¡¨ç¤ºâˆ

![](/static/2020-10-08-14-44-48.png)

* mantissaå…¨0
* exponentå…¨1
* sign 1/0
  * æ­£inf
  * è´Ÿinf

### NaN

ğŸŠ æ²¡æœ‰ç‰¹å®šè¡¨ç¤ºå½¢å¼

* exponetå…¨`1`
* mantissaé`0`
* **float64å¯ä»¥æœ‰`2^52-1`ç§ä¸åŒçš„NaNs**

Not a Numberï¼ˆæµ®ç‚¹ï¼‰

* è¡¨ç¤º**invalid**çš„æ•°
* `0/0`
* `inf/inf`
  * `+inf`
  * `-inf`
* `inf - inf`
* `inf+ -inf`
* `sqrt(x)`
  * `x<0`
* `log(x)`
  * `x<0`

NaNç‰¹æ€§

![](/static/2020-10-08-14-48-04.png)
![](/static/2020-10-08-14-54-49.png)

* propagates
  * **æ‰€æœ‰æ¶‰åŠNaNçš„æµ®ç‚¹è¿ç®—ï¼Œéƒ½è¾“å‡ºNaN**
  * é™¤äº†`1.0**nan=1.0`
* ä¸NaNè¿›è¡Œé€»è¾‘æ¯”è¾ƒ
  * è¾“å‡º`false`
  * **NaNä¸ç­‰äºä»»ä½•å€¼ï¼Œä¹Ÿä¸ç­‰äºNaNæœ¬èº«**
  * `np.isnan(a)`åˆ¤æ–­æŸarrayæ˜¯å¦æœ‰`nan`å€¼ï¼Œ`a!=a`ä¸è¯¥å‡½æ•°ä½œç”¨ç›¸åŒ
* ä¸ä¸pythonçš„`False`

ğŸŠ é€šå¸¸ç”¨äº

* è¡¨æ˜æŸæ“ä½œé”™è¯¯
* æˆ–ä½œä¸ºarrayçš„å ä½ç¬¦ï¼ˆdataset missing dataï¼‰

#### NaN as a result

![](/static/2020-10-08-15-02-45.png)

#### NaN as a mask

Nanæœ‰æ—¶ä½œä¸ºæ•°æ®ç¼ºå¤±éƒ¨åˆ†çš„è’™ç‰ˆ
![](/static/2020-10-08-15-03-59.png)

## Roundoff & precision

æµ®ç‚¹æ•°æ“ä½œè¿ç®—å¯èƒ½é€ æˆ**roundoff error(èˆå…¥è¯¯å·®)**

![](/static/2020-10-08-15-20-39.png)

* æµ®ç‚¹æ•°ç²¾åº¦ä¸åŒ

å¦‚æœä½ æœ‰ä¸€ä¸ªå€¼é›†åˆï¼Œè¿™äº›å€¼æ˜¯å¦è¢«æ’åºæ˜¯å¦ä¼šé€ æˆå¯¹å…¶æ ‡å‡†å·®çš„å½±å“ï¼Ÿ

![](/static/2020-10-08-15-28-23.png)

* ä¼šï¼Ÿ

### roundoff problem

![](/static/2020-10-08-15-37-05.png)
ï¼Ÿï¼Ÿï¼Ÿ

repeated operationsé‡å¤æ“ä½œé€ æˆçš„é—®é¢˜
![](/static/2020-10-08-15-40-00.png)

financial operations
![](/static/2020-10-08-15-40-31.png)

* æ¶‰åŠç»æµä¸è¦ä½¿ç”¨æµ®ç‚¹æ•°æ“ä½œï¼Œä½¿ç”¨å…¶ä»–åè¿›åˆ¶æ•°å­—å½¢å¼ï¼ˆæ˜ç¡®å®šä¹‰å¥½äº†roundoffè§„åˆ™çš„ï¼‰

### roundoff error

roundoff error(èˆå…¥è¯¯å·®)

![](/static/2020-10-08-15-41-49.png)
![](/static/2020-10-08-20-34-42.png)

* åœ¨**æŸäº›æƒ…å†µ**ä¸‹ï¼Œ**åˆ†é…å¾‹&ç»“åˆå¾‹ä¸é€‚ç”¨äºæµ®ç‚¹æ•°**
* æ“ä½œé¡ºåºä¹Ÿä¼šé€ æˆå½±å“

![](/static/2020-10-08-20-36-00.png)

* roundoff error - ä¸åŒè¿ç®—é¡ºåºå¯¼è‡´

## Laws of floating-point disaster

åŸºæœ¬è¿ç®—æ³•åˆ™

![](/static/2020-10-08-15-44-42.png)
![](/static/2020-10-08-16-23-03.png)
![](/static/2020-10-08-16-23-40.png)

* `x+y`
  * maginitude errorï¼Œ
  * å¦‚æœxï¼ŒyèŒƒå›´ä¸åŒï¼Œä½†åšåŠ æ³•
* `x-y`
  * cancellation error,
  * å¦‚x~=y(xï¼Œyéå¸¸ç›¸ä¼¼ï¼Œä½†åšå‡æ³•)

ğŸŠ dont use `==` equality for test the comparison

![](/static/2020-10-08-19-38-51.png)
![](/static/2020-10-08-19-41-59.png)
![](/static/2020-10-08-19-54-14.png)
![](/static/2020-10-08-19-54-49.png)

* ä½¿ç”¨`np.allclose(x,y)`æ¯”è¾ƒ
  * ä¸è¦ä½¿ç”¨`==`ï¼Œå¯èƒ½ä¼šå‡ºç°roundoffè¯¯å·®
* è®¾å®šé˜ˆå€¼ï¼ˆepislonï¼‰æ¯”è¾ƒ**å·®å¼‚çš„ç»å¯¹å€¼(ç»å¯¹è¯¯å·®)**
  * `|x-y|<Ïµ`
  * ç»å¯¹è¯¯å·®<ç›¸å¯¹è¯¯å·®

### Machine precision(epsilon)

æœºå™¨ç²¾åº¦ï¼ˆepsilonï¼‰

ä½•ä¸ºepsï¼Ÿ

![](/static/2020-10-08-20-02-47.png)
![](/static/2020-10-08-20-09-04.png)
![](/static/2020-10-08-20-10-13.png)

* bifæŸ¥çœ‹epsilon
  * `print(np.finfo(np.float32))`
  * `print(np.finfo(np.float32).eps)`
  * `print(np.finfo(np.float64))`
  * `print(np.finfo(float))`

ğŸ¬ IEEE754ä¿è¯**ç›¸å¯¹è¯¯å·®**`relative error(ä¸€ä¸ªæ¯”å€¼)<epsilon`

![](/static/2020-10-08-20-13-06.png)

* ç»å¯¹è¯¯å·®ï¼ˆabsolute errorï¼‰ï¼šï¼ˆæœ‰å•ä½ï¼‰ï¼›

### Extension: abs & relative error

ç»å¯¹è¯¯å·®abs

* å‡å®šä¸¤å‘é‡x1, x2ï¼Œåˆ™x1ï¼Œx2çš„ç»å¯¹è¯¯å·®ä¸ºabs(x1 - x2)
* **æœ‰å•ä½ï¼Œæ•°å€¼**

ç›¸å¯¹è¯¯å·®epsilonï¼ˆrelative errorï¼‰

* `abs(x1-x2)/|x2|`
  * ç®—å‡ºçš„æ˜¯x1çš„ç›¸å¯¹è¯¯å·®ï¼Ÿ
* <font color="red">åœ¨èŒƒæ•°æ„ä¹‰ä¸‹ï¼Œ**ç›¸å¯¹è¯¯å·®å¯ä»¥ç†è§£ä¸ºæœ‰æ•ˆæ•°ä½**</font>
* **æ— å•ä½ï¼Œæ¯”ä¾‹**

ğŸ¬ ç”¨**ç»å¯¹è¯¯å·®æ— æ³•æ¯”è¾ƒä¸åŒæµ‹é‡ç»“æœçš„å¯é ç¨‹åº¦**ï¼Œäºæ˜¯äººä»¬ç”¨**æµ‹é‡å€¼çš„ç»å¯¹è¯¯å·®ä¸æµ‹é‡å€¼ä¹‹æ¯”æ¥è¯„ä»·ï¼Œå¹¶ç§°å®ƒä¸ºç›¸å¯¹è¯¯å·®**

* ç”¨`%`ç¤ºï¼Œå¹¶å¯åŒ–æˆç™¾åˆ†æ¯”ï¼Œä¹Ÿå«ç™¾åˆ†è¯¯å·®

## Array layout & structure

![](/static/2020-10-08-22-04-06.png)

---

arrays lay out in memory

![](/static/2020-10-08-22-06-43.png)

ndarraysç‰¹æ€§

* å›ºå®šï¼Œæå‰å®šä¹‰å¥½çš„shape
* é•¿æ–¹å½¢
* å›ºå®šæ•°æ®ç±»å‹
* å¤šç»´multidimensional

ğŸ¬ é—®é¢˜

* ä¸ºä»€ä¹ˆå€’ç½®ä¸º`O(1)`æ—¶é—´ï¼Œ`+1`ä¸º`O(N)`æ—¶é—´
* ä¸ºä»€ä¹ˆ`==`æŸäº›æƒ…å†µä¸‹ä¸åº”ç”¨äºarray
* `np.ones((3,3)) / np.zeros((3,3))`
* ä¸ºä»€ä¹ˆä¸æ”¯æŒragged shapeçš„arrayï¼ˆä¸è§„åˆ™ï¼‰?

### Array Data Structure

data in array is **tightly packed** in memory so it **only takes up small number of memeory**

![](/static/2020-10-09-22-55-26.png)
![](/static/2020-10-09-22-59-29.png)

* regardless of the **array shape**, the storage is just **a sequence of numbers with a header at the start**
  * `np.ravel()`to **see the flat sequenceï¼ˆwhich actually sotred in memoryï¼‰**. unravels an array into the elements as a **1D vector**ã€‚
    * **å°†å¤šç»´æ•°ç»„é™ä¸ºä¸€ç»´,è¿”å›è§†å›¾**
    * æ³¨æ„ä¸`np.flatten()`åŒºåˆ†

### Strides & Shape

è·¨åº¦ & å½¢çŠ¶

strides

![](/static/2020-10-10-14-59-30.png)
![](/static/2020-10-10-15-02-53.png)

* å®ç°å¤šç»´indexingï¼Œå¯åˆ©ç”¨è·¨åº¦æœºåˆ¶
* **è·¨åº¦ - strides**
  * <font color="red">enables system to index efficiently while keep it still a flat sequence tightly packed in memory</font>
* **1 stride 1 dimension**
  * each stride indicates that how many **BYTES** takes to move forward to the first element of next dimension
  * è·¨åº¦ï¼Œè¡¨ç¤ºä»**å½“å‰ç»´åº¦å‰è¿›é“ä¸‹ä¸€ç»´åº¦**çš„å½“å‰ä½ç½®æ‰€éœ€è¦â€œè·¨è¿‡â€çš„**å­—èŠ‚æ•°**
  * <font color="blue">strideé€šå¸¸ç”±bytesæŒ‡å®šï¼Œæé«˜å†…å­˜è®¿é—®æ•ˆç‡</font>
* 1D vector
  * stride=å†…ç½®æ•°æ®ç±»å‹çš„å­—èŠ‚é•¿ï¼Œå¦‚float64,stride=`8B`

ğŸŠ è·å–2D arrayçš„æŸå…ƒç´ 

![](/static/2020-10-10-15-02-34.png)

* `index [i,j]`
* `i * stride[0] + j * stride[1]`

### Dope Fiends: dope & iliffe vetor

dope vector

* refers to the **striding information**
  * has a header specifies how to index

**iliffe vector**(ä¼Šåˆ©å¤«å‘é‡ï¼ŒæŒ‡é’ˆå‘é‡ï¼Ÿ)

* using **nested pointers** to refer to multidimensional array ä½¿ç”¨åµŒå¥—æŒ‡é’ˆå®šä¹‰å¤šç»´array
  * `[[1,2,3], [4,5,6], [7,8,8]]`
* <font color="red">can store ragged array å¯ä»¥å­˜å‚¨ä¸è§„åˆ™array</font>
  * much **less efficient for large numerial operation** compared by **dope vectorsï¼ˆdoesnt have any intermidiate infoï¼‰**

---

java iliffe vector

```java
int[][] a =new int[8][8];
elt_3_4 = a [3][4];
```

java dope vector

```java
int [] a = new a[64];
row_offset = 8;
elt_3_4 = a[row_offset*3+4];
```

### sketch of an array data structure

c structså®šä¹‰

![](/static/2020-10-10-15-31-23.png)
![](/static/2020-10-10-15-32-34.png)

### Vectorised Operation

å¾ˆå¤šæ“ä½œå¯ä»¥ä¸æ¶‰åŠè·¨åº¦strides

![](/static/2020-10-10-15-45-19.png)

* å¦‚ä¸¤ä¸ªarrayç›¸åŠ 

### Strided arrays in practice

![](/static/2020-10-10-15-46-07.png)

numpyå·²å®ç°å¥½

### Transposing

å€’ç½®

![](/static/2020-10-10-16-01-51.png)
![](/static/2020-10-10-16-51-40.png)
![](/static/2020-10-10-16-27-43.png)

* exchange the shape elements & the strides in the header
* **transposing: O(1) - regardless of array size**

### Rigid Transformations

arrayåˆšä½“å˜æ¢ - rigid transformations

* ç±»ä¼¼flipping & transposing
  * but **doesnt change the data** in the array
* **only change**: **the strides** used to compute indexing
  * <font color="red">thus, don depend on the size of the array and takes O(1) time (or O(number of dimensions of the array) technically)</font> 

---

original array
![](/static/2020-10-10-16-08-34.png)

* shape(6,5)
* strides(40,8)

transposing
![](/static/2020-10-10-16-07-53.png)

* `array.T`
* shape(5,6)
* strides(8,40)
* exchange the **shape elements & strides**

flipped up/down
![](/static/2020-10-10-16-09-38.png)

* `np.flipud(array)`
* shape(6,5)
* strides(-40,8)
* reverse the array by setting the memory block pointer to point to the end of array
* **setting the strides to be negative**

flipped left/right
![](/static/2020-10-10-16-13-55.png)

* `np.fliplr(array)`
* shape(6,5)
* strides(40,-8)
* reverse the array by setting the memory block pointer to point to the end of array
* **setting the strides to be negative**

rotated 90(left)
![](/static/2020-10-10-16-14-45.png)

* `np.rot90(array)`
* shape(5,6)
* strides(-8,40)

### C & Fortran order

2 different ways to **represente data stored in memory**

numpy default stride is the last index changes first

![](/static/2020-10-10-16-55-17.png)

* stride - `[48,8]`

---

![](/static/2020-10-10-16-57-10.png)
![](/static/2020-10-10-16-57-53.png)
![](/static/2020-10-10-17-02-33.png)

**C ordering**(row-major order)

* default in C-based language
* numpy

**Fortran ordering**(column-major order)

* sometimes still used in older software

## Numpy Types

unless specify a different type using `dtype=...` properties

![](/static/2020-10-10-17-07-28.png)

* defautlt would be
  * **`float64`** if float point number are created
  * or **`int32`**

ğŸŠ convert

* `.astype()`
  * **convert the array elements to the specified type**

## Tensor operations

high-ranked array(tensor)

### reshape

rigid transformationsåˆšä½“å˜æ¢

* `np.fliplr()`
* `np.flipup()`
* `np.transpose()`

é™¤ä¸Šï¼Œä¹Ÿå¯ä»¥å¯¹arrayè¿›è¡Œreshape

* **data elementä¸èƒ½è¢«æ”¹å˜**
* **elementæ€»æ•°reshapeè¿‡ç¨‹ä¸­ä¸èƒ½æ”¹å˜**

`ravel()` shows the array shape just change how it is indexed

![](/static/2020-10-10-17-31-16.png)
![](/static/2020-10-10-17-26-19.png)

* **flat sequence representation stored in memory** regardless of its shape

#### Reshaping rules

![](/static/2020-10-10-17-29-21.png)
![](/static/2020-10-11-14-20-24.png)

* total number of elements remain unchanged **å…ƒç´ æ€»æ•°ä¸å˜**
* order of elements(in memory) remain unchanged **å…ƒç´ é¡ºåºä¸å˜**
* fills up the last dimension firstå…ˆå¡«æ»¡æœ€åä¸€ç»´
  * ä¸ä¼šçœŸçš„æ”¹å˜å†…å­˜ä¸­åŸarrayï¼Œåªæ˜¯æ”¹å˜å…¶è·¨åº¦strides

ğŸŠ reshapeæ–°ç”Ÿæˆæ•°ç»„å’ŒåŸæ•°ç»„å…¬ç”¨ä¸€ä¸ªå†…å­˜ï¼Œä¸ç®¡æ”¹å˜å“ªä¸ªéƒ½ä¼šäº’ç›¸å½±å“ã€‚

![](/static/2020-10-11-14-35-15.png)

### Advanced reshaping: squeezing & adding dimensions

scalar product(dot product)
![](/static/2020-10-11-14-41-27.png)

* row by row

![](/static/2020-10-11-14-42-31.png)
![](/static/2020-10-11-14-43-20.png)

* but when row * **column(1d vector transposing)**
  * excactly the same thing

æ‰€ä»¥å¤„ç†1Dvectorï¼ˆä½œä¸ºä¸€æ•´åˆ—ï¼Œä¸€æ•´è¡Œï¼‰éœ€è¦æ˜¾å¼æ·»åŠ æ–°ç»´åº¦

![](/static/2020-10-11-14-45-32.png)
![](/static/2020-10-11-14-46-21.png)

* å› ä¸º1Dvectorä¸æ˜¯row/column vector
  * outer productéœ€è¦åº”ç”¨äº2D matricesï¼ˆ**singleton dimension,any dimension for which size(A,dim) = 1**ï¼‰
* å¯ä»¥é€šè¿‡`reshape`å®Œæˆæ·»åŠ æ–°ç»´åº¦`1`
  * **æ³¨æ„æ­¤ä¾‹yå·²ç»å€’ç½®äº†**

### Add Dimensions

ä¸ä½¿ç”¨reshapeæ·»åŠ æ–°ç»´åº¦çš„ç‰¹å®šè¯­æ³•ï¼Œindexä¸ŠæŒ‡å®š
![](/static/2020-10-11-14-53-14.png)
![](/static/2020-10-11-14-53-43.png)
![](/static/2020-10-11-14-54-46.png)
![](/static/2020-10-11-14-55-31.png)

* **`None`**
* **`np.newaxis`**

**remove the dimensions**, index=`0`
![](/static/2020-10-11-14-56-32.png)

### Squeezing

often the result of a complex calculation is **a multidimensional array with a bunch of singleton dimensions**

---

**squeezing**

![](/static/2020-10-11-15-10-50.png)

* `np.squeeze()`
* **removes all the singleton dimensions in one go**

### Elided Axes

çœç•¥ç»´æ•°

* æœ‰æ—¶å€™ä¼šå¿˜è®°å“ªä¸€ç»´å’Œå“ªä¸€ç»´æ˜¯ä»€ä¹ˆï¼Œæ“ä½œæ—¶éš¾ä»¥åˆ†è¾¨
* å¯ä»¥ä½¿ç”¨`...`çœç•¥indexingè¡¨è¾¾

[reference](https://www.codenong.com/118370/)

![](/static/2020-10-11-15-14-19.png)
![](/static/2020-10-11-15-16-46.png)
![](/static/2020-10-11-15-21-05.png)

### swapping & rearranging axes

å¯ä»¥äº¤æ¢arrayçš„ç»´åº¦çš„å…ƒç´ 

![](/static/2020-10-11-15-28-48.png)
![](/static/2020-10-11-15-44-50.png)

* `np.swapaxes(a, axis1, axis2)`
* takes `O(1)`time
  * array itself not changed, and rearrangement is just a simple change of the array stides and shape

#### the swap, reshape, swap dance

![](/static/2020-10-11-15-47-08.png)

### einsum

 Einstein summation notation

![](/static/2020-10-11-15-50-52.png)
![](/static/2020-10-11-15-53-43.png)
![](/static/2020-10-11-15-54-55.png)

* reorder higher-rank tensor **simplest form**
* use `np.swapaxes` very fast but confusing
* **Einstein summation notation**
  * allows a specification of **1 letter names** for **each dimensions**
  * `ijklmn...` an write the dimension rearrangement as a string
* rearrangement syntax
  * `np.einsum("ijk -> jik",array)`