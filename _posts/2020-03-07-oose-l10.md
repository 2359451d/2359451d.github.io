---
layout: post
title: "OOSE LECTURE 10 - 设计模式 - 策略"
date: 2020-03-07
excerpt: "软工 - 设计模式, Strategy Design Pattern, OO设计法则"
tags: [课题, code, 软件工程, 2020, oose, 设计模式]
feature: https://previews.123rf.com/images/karpenkoilia/karpenkoilia1709/karpenkoilia170900117/86423976-modern-line-web-concept-for-programming-linear-web-banner-for-coding-.jpg
comments: true
---

* 目录
{:toc}

![](/static/2020-03-08-04-36-56.png)

## Learning Outcomes

![](/static/2020-03-08-05-38-21.png)
- 继承中问题(接口)
- 何时应用组合于继承之上
- 理解为程序提供接口
- 不同设计理念

## Problem: Inheritance & Interfaces

![](/static/2020-03-08-06-15-28.png)![](/static/2020-03-08-06-42-55.png)
- 继承是OO设计中核心原则之一
- 滥用继承会造成耦合,项目的后需更改将不灵活
- 当存在过多`is-a`关系时考虑是否滥用继承

### Example: Simple SimUDuck App

![](/static/2020-03-08-06-45-11.png)
- 初始设计: Duck超类供其他Duck类型**继承**

🍊 步骤 (滥用继承)
![](/static/2020-03-08-06-46-33.png)
1. Duck超类
- `quack() & swim()`普通方法，子类直接继承(如要求特定则覆写)
- `display()`抽象方法，每个子类定义不同表现

![](/static/2020-03-08-06-47-21.png)
2. 不同具体类实现Duck中特定方法

![](/static/2020-03-08-06-48-31.png)
3. 添加`RubberDuck`类，更改继承来的父类方法`quack()`

![](/static/2020-03-08-06-54-07.png)
4. `Duck`超类添加新操作`fly()`
- 此时`RubberDuck`覆写该方法确保`fly()`不会表现特定行为

![](/static/2020-03-08-06-57-27.png)
5. `DecoyDuck`覆写1个抽象方法`display()`。同时要额外覆写2个具体方法`quack() & fly()`确保不会表现出特定行为

#### Problem: Using Inheritance

![](/static/2020-03-08-06-59-10.png)

> Problem: 覆写过多父类方法。

- 滥用继承
- 类之间过多冗余代码
- 父类可读性差.
- 父类添加新功能，需要修改其他类
- 编译时期分配决定所有行为(无分派)

#### Solution: Using Interface

> 提升模块性，使用接口而不是继承

![](/static/2020-03-08-08-04-49.png)
- 接口允许不同类共享相似特性
  - 例如,ducks共享`fly()`

- 接口允许存在两个相似的行为不同的类
  - 例如，某些ducks实现`fly()`，某些不表现该行为

🍊 步骤

![](/static/2020-03-08-08-09-48.png)
1. 创建两个特定接口(不是所有Duck子类都具有的行为)`Flyable` & `QUackable`

![](/static/2020-03-08-08-23-47.png)
2. `Duck`超类及其子类，
- 修改后，`Duck`类仅保留`swim()`具体方法和`display()`抽象方法
  - `swim()`大多情况下不会被覆写，且每个子类都具有该行为
  - `display()`子类覆写该抽象方法，表现行为不同

![](/static/2020-03-08-08-31-55.png)
3. 继承特定接口&方法
- `MallarDuck` & `RedheadDuck` 实现`fly() & quack()`方法
- `RubberDuck` 实现`quack()`
- `DecoyDuck`不实现特定接口

---

##### Problem: Interface

🍬 接口的使用引入了新问题
![](/static/2020-03-08-08-51-01.png)
- 代码复用性差
  - 假设40种Ducks，每个子类都需要实现相关行为
- 如修改`fly()` & `quack()`方法
  - 可能需要修改所有实现了该方法的具体类
- 所有行为仍在编译时期分派
  - 不允许运行时期的行为改变

#### Rethink: Inheritance & Interface

🍬 考虑前两种设计不合理之处
![](/static/2020-03-08-09-02-01.png)
- 继承
  - 需要改变每个具体类的行为
- 接口
  - 不支持代码复用
  - 需要改变特定行为时，需要修改相关子类种方法

## OO Design Pattern

🍬 前略 PHAME(基本软件设计原则) & SOLID原则(项目可维护&扩展)

### 🍊 OO设计原则1&2

🍊 设计原则1
![](/static/2020-03-08-09-22-35.png)
- 分辨程序中改变的部分&不变的部分
  - 数据与行为

🍊 设计原则2
![](/static/2020-03-08-10-10-00.png)
- 针对接口编程，而非（接口的）实现


### Encapsulation

🍬 Lecture 5 Note - 基本软件设计原则
![](/static/2020-03-08-09-52-18.png)
![](/static/2020-03-08-09-52-38.png)

![](/static/2020-03-08-09-32-49.png)
- 如果程序某部分经常需要改变，意味着该部分可以被分离出去
  - 分装出去该行为后，增删功能不会改变剩下结构

---
🍬 针对封装性原则，修改源程序
🍙 源程序`display()`为抽象方法

---

#### 🍊 应用设计原则1

找出变化的部分

![](/static/2020-03-08-09-58-04.png)
![](/static/2020-03-08-10-00-47.png)
![](/static/2020-03-08-10-01-05.png)
![](/static/2020-03-08-10-03-28.png)
![](/static/2020-03-08-10-04-12.png)
- `quack()` & `fly()`某些类需要特定实现
- `swim()`抽象类具体方法，目前不需要改变，所有子类默认继承
- `display()`抽象类抽象方法，每个子类实现特定

![](/static/2020-03-08-10-07-18.png)
<font color="red">为经常改变的部分，封装成新类</font>

---

#### 🍊 应用设计原则2

分离出变化的行为`quack()&fly()`，提供接口进行管理
- 并在不同类中实现该两个接口，各具体类行为表现不同，以供后续子类继承，**运行时期供Duck类引用类字段**
![](/static/2020-03-08-10-23-16.png)
![](/static/2020-03-08-10-29-51.png)

🍬 result
![](/static/2020-03-08-10-32-08.png)
- 不依赖实现行为，而是依赖接口

![](/static/2020-03-08-10-34-08.png)
- 不再需要在Duck类(具体类)中做特定实现
  - 之前需要在每个特定Duck子类中实现特定`quack() & fly()`方法
- 特定的实现在运行时期被分配
  - 通过Duck类的**引用类属性(父类对子类的引用，表现为多态)，实际的行为在运行时期由最终底层类型**

#### 🍊 应用设计原则3

![](/static/2020-03-08-17-27-32.png)
![](/static/2020-03-08-17-30-50.png)
- 优先使用（对象）组合，而非（类）继承
- 定义一系列的算法,把它们一个个封装起来
- **允许在运行时期决定行为的分派**

#### Final Class Diagram

![](/static/2020-03-08-12-07-04.png)

## Strategy Design

![](/static/2020-03-08-12-16-21.png)
- `接口&实现类`组合封装需要特定实现的行为
- 不需要改变的行为直接从父类继承

🍙 私认为核心在于: 组合封装（接口&具体类）需要特定实现的方法，父类对外提供设置特定状态引用的操作（子类实现特定抽象方法，继承不变的方法，如有需要，子类实现行为接口）

---
![](/static/2020-03-08-16-38-10.png)
![](/static/2020-03-08-16-40-23.png)
![](/static/2020-03-08-16-42-34.png)
🍬 定义
![](/static/2020-03-08-16-43-54.png)
- 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换
- 允许算法独立于客户端变化

🍬 特点
- 将改变的算法从主要继承层次中分离出来，可以在**运行时期决定特定对象所实际调用的底层方法**
- <font color="red">行为相同的不同类对象，可以进行代码复用(此时行为已经分离出去)</font>

## Has-a vs Is-a Relationships

![](/static/2020-03-08-16-51-35.png)
- 继承`is-a relationship`
- 前例单纯继承，有些类继承/覆写了不需要冗余的方法

![](/static/2020-03-08-17-21-30.png)
- 引入接口后`has-a relationship`
- 不直接继承行为，而是通过特定行为对象组合实现最终底层行为

## Summary

![](/static/2020-03-08-17-40-20.png)
- 策略模式
  - 定义一系列行为算法进行封装，(在抽象类中提供对外设置方法，具体子类具体实现)
  - 并且使它们可相互替换
- 本模式使得算法可独立于使用它的客户端而变化